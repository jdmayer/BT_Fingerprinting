
\chapter{Design and Implementation}
\label{cha:implementation}

This chapter covers the design and implementation of the previously mentioned prototype (requirements see \hyperref[cha:requirements]{chapter 3}). The first section describes the architecture of the protoype with the help of application scenarios. The second section covers programming details and the last section gives a short overview of the visualisation of the prototype.

\section{Architecture}

\subsection{Used Fingerprinting Techniques}
As seen in \autoref{sec:Techniques} there are various web browser fingerprinting techniques. To show how easy it can be to program such a technique the prototype is used to implement two of those techniques.\\ 
There are various factors which influenced the decision making on which fingerprinting techniques should be used and in the end the decision fell on browser specific and canvas fingerprinting.\\\\
Browser specific fingerprinting was chosen as it was the first utilized fingerprinting technique and delivers a good example to show how easy it is to retrieve unique information from a user.\\\\
Canvas fingerprinting was chosen as it aquires the information needed for the hash over rendering for example fonts which no other technique does. Further a study conducted in 2016 by S. Englehardt and A. Narayanan detected that 5.1\% of the Alexa Top 1000 used canvas fingerprinting scripts . Anyway, this percentage declined the further down the Top Alexa 1 Million they crawled.(\textcite{engl16}, p.12)\\


\subsection{Application scenario}
As a mean of explanation a application scenarios will be used to outline the concept this prototype is based on. Further it will give a short overview of how browser specific and canvas fingerprinting work when executing the prototype.\\

\subsubsection{General concept}
In general the prototype depicts a simple client-server application. \\
The main parts of this application scenario are:\\
\begin{itemize}
	\item \textit{Servlet}, can be seen as a controller, which manages requests and responses.
	\item \textit{JavaServerPage }(short JSP), holds HTML for the webpage and JavaScript.
	\item \textit{web.xml}, is a web application deployment descriptor, which means it defines everything about the application the server needs to know. In this case what the welcoming page is.
	\item \textit{Ajax}, used for the datatransfer from the website back to the servlet.
	\item \textit{JSON}, two local JSON files are used to hold the created fingerprints for comparison.\\\\
\end{itemize} 

\autoref{fig:ConceptPrototype} is a simple outline of the general sequence of operations.

\begin{figure}[H]
	\centering
	\includegraphics[width=460pt, height=200pt]{applicationScenarioPrototype.png}
	\caption{Concept of the prototype\\}
	\label{fig:ConceptPrototype}
\end{figure}

\begin{enumerate}
	\item The client requests the prototype website with the following url:\\ \textit{http://[ip-address]:8080/FingerprintPrototype/index.jsp}\\
	Due to the servlet the prototype can be accessed from different devices when the server runs, which makes the prototype easily portable.
	\item The servlet receives the request and renders the welcoming page which is stated in WEB-INF\textbackslash web.xml (in this case index.jsp).
	\item The JSP is then rendered in the clients browser.
	\item The user can click one of the depicted buttons to create his fingerprint. The button triggers a JavaScript method which will lead to create the respective fingerprint. As JavaScript is executed directly in the users browser, JavaScript needs to be enabled in the browser.
	\item When the calculation of the fingerprinting hash is done Ajax is used to deliver the new hash to the Servlet.
	\item The servlet then compares the newly created hash with already existing ones which are stored in a local JSON file. If the fingerprint is not recognised it is added along with the current date and time to the JSON file.
	\item Thereafter the servlet renders a short message in form of static HTML in the JSP on the website of the user. This message informs the user if he has been recognised or else if this was his first visit on the prototype.\\
\end{enumerate}
Depending on which kind of fingerprint has to be created, the following sections will go into detail with what happenes in step 4 which is described above.


\subsubsection{Browser specific fingerprinting}\label{sec:appBrowserSpecific}

The following \autoref{ConceptBrowserSpecificFingerprinting} displays an application scenario which describes what happens when the user choses to create a browser specific fingerprint:

\begin{figure}[H]
	\centering
	\includegraphics[width=220pt, height=150pt]{applicationScenario_browserSpecificFP.png}
	\caption{Concept of browser specific fingerprinting\\}
	\label{ConceptBrowserSpecificFingerprinting}
\end{figure}

\begin{enumerate}
	\item The browser specific fingerprint JavaScript method uses the window object to retrieve information about the browser (e.g. navigator and screen properties).
	\item The acquired information is then combined with further acquired information (e.g. fonts and GPU).
	\item The created hash is then passed back to the server (see figure \ref{fig:ConceptPrototype}).\\
\end{enumerate}


\subsubsection{Canvas fingerprinting}\label{sec:appCanvas}
The following \autoref{ConceptCanvasFingerprinting} depicts an application scenario which describes what happens when the user choses to create a canvas fingerprint:

\begin{figure}[H]
	\centering
	\includegraphics[width=220pt, height=150pt]{applicationScenario_canvasFP.png}
	\caption{Concept of canvas fingerprinting\\}
	\label{ConceptCanvasFingerprinting}
\end{figure}

\begin{enumerate}
	\item The canvas fingerprint JavaScript method renders a hidden canvas in the browser. The canvas contains different fonts, colors and forms.
	\item  With the help of the toDataURL() method the content of the canvas is converted into pixel data which is retrieved by the JavaScript method.
	\item The retrieved pixel data is then concated with GPU details (only in this prototype).
	\item The created hash is then passed back to the server (see figure \ref{fig:ConceptPrototype}).\\
\end{enumerate}


\section{Implementation details}
As shown with the help of the application scenario (see figure \ref{fig:ConceptPrototype}) the prototype is a simple client server application. \\\\
Following subsections cover the implementation details about the prototype. How exaclty the fingerprints are composed will be outlined in subsection \autoref{sec:codeBrowserSpec} and \autoref{sec:codeCanvas}.

\subsection{Servlet}
The servlet \textit{(Fingerprinting.java)} is working like a controller which is taking care of requests and responses. The main focus lays on the doPost() method which is in charge of the hash comparison. The newly created hash is compared with all existing hashes from a local JSON file. Here is to considered that two different files are In case that the local JSON file does not contain the new hash, a new JSON object with the current date, time and the hash is added to the file.\\
Here is to be considered that two different files are used to save the hashes. This is due to the fact that the two fingerprinting techniques create completely different hashes which can not be compared to one another.\\\\
At the end of the method a feedback for the user is created which then is rendered in the JSP. The following code snippet shows how a PrintWriter is used to send HTML code as a response to the browser.

%\begin{program}
\begin{JavaCode}
	PrintWriter out = response.getWriter();
	if(existingUser) {
		out.println("<p style=\"color:red;\">");			
		out.print("I remember you!");
		out.println("</p>");
		out.print("You first visited this prototype on:" + firstVisit);
	}
	else {
		out.print("This is your first visit!");
	}
\end{JavaCode}
%\caption{Output for user}
%\label{codeServletOutput}
%\end{program}


\subsection{JSP}
The JavaServerPage \textit{(index.jsp)} contains HTML as well as JavaScript code. The HTML is used to render the prototype in the users browser while JavaScript is executed upon a button click which starts the fingerprinting process (see \autoref{sec:codeBrowserSpec} and \autoref{sec:codeCanvas}). Apart from the bare creation of the fingerprints, JavaScript is also using Ajax to forward the generated hash back to the servlet.\\

%\begin{program}
\begin{JsCode}
	$.ajax({
		type : 'POST',
		data : {
			method : 'canvas',
			hash : hash
		},
		url : 'Fingerprinting',
		success : function(result) {
			$('#result1').html(result);
		}
	});
\end{JsCode}
%\caption{Ajax sends hash to servlet}
%\label{codeAjax}
%\end{program}
As seen in the code snippet above, Ajax posts two different data items. "method" is used to make a distinction between the transfer of a canvas (like above) or a browser specific fingerprinting hash. The "hash" data simply contains the created hash variable.\\\\
On success of the transfer the response of the servlet will be rendered in the HTML component with the id "result1". As seen below the response will be rendered where the button, which called the fingerprinting method, was previously rendered.\\
%\begin{program}
\begin{HtmlCode}
	<div class="panel-footer" id="result1">
		<button type="button" class="btn btn-info"
		onclick="fingerprint_canvas();">Check Canvas Fingerprint</button>
	</div>
\end{HtmlCode}
%\caption{Reference in HTML for response}
%\label{codeHTMLReference}
%\end{program}

\subsection{Fonts method} \label{sec:fonts}

Javascript's sandboxed inside the browser and doesn't have privileges to read from the clients disk for security reasons.

You need to have your own list of fonts to check, then you have an array of installed fonts by checking each of the list to see which one is installed.

The difference in widths will tell you the availability of the fonts installed on the client's computers because the browser will fall back to its default font. So you probably need to do some invisible testing for text widths to determine if a font is installed.

https://stackoverflow.com/questions/3597682/how-to-iterate-the-installed-fonts-using-javascript



As installed fonts in a browser can not be directly queried, a work around is used to check which fonts are installed. This workaround simply renders specifically stated fonts and checks through the rendering if they are installed.\\\\
To execute this workaround a detector is needed. The detector used in this prototype was implemented by \textit{Latil Patel}(\textcite{fontDetect}).\\\\
As already mentioned, the detector can only check explicitly queried fonts wherefore the following method is needed (which uses Patels detector):\\

\begin{JsCode}
	function get_fonts() {
		var fonts = [ "Arial", "	Helvetica", "Verdana", "Comic Sans",
		"Windings", "Webdings", "Georgia", "Rotterdalle", "Sweet Cake",
		"Coldiac", "Kilauea", "Blacker", "Rubik", "Cormorant" ];
		var fontDetector = new Detector();
		var fontExist = "";
		for (var i = 0; i < fonts.length; i++) {
			fontExist += fontDetector.detect(fonts[i]) + " - ";
		}
		return fontExist;
	}
\end{JsCode}
The detector simply renders all fonts which are called by the method above and checks if they can be rendered. If so, they are available and a respective boolean is returned and added to a string which is eventually the return value of the \textit{get\_fonts()} method. 

\subsection{GPU method} \label{sec:graphicCard}
To retrieve the users grapic processing unit a function implemented by \textit{Lesha Rubinshtein} (\textcite{gpuDetect}) is used. As seen in the code snippet below the function creates a canvas (like the canvas fingerprinting technique) and uses it to retrieve GPU specific information.\\

\begin{JsCode}
	function get_gpu() {
		var canvas = document.createElement('canvas');
		var gl;
		var debugInfo;
		var vendor;
		var renderer;
		
		try {
			gl = canvas.getContext('webgl')
			|| canvas.getContext('experimental-webgl');
		} catch (e) {
		}
		
		if (gl) {
			debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
			vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
			renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
		}
		
		return renderer;
	}
	
\end{JsCode}

\subsection{Browser specific fingerprinting} \label{sec:codeBrowserSpec}

As outlined in \autoref{specFP} the browser specific fingerprint consists of multiple pieces of information which are retrieved from the user. The method used in this prototype retrieves its pieces of information mainly from a browser object called \textit{window}.

\subsubsection{Window}
The window object is a property which is supported by all main browsers. It is automatically created by the browser and holds information about the window (\textcite{javatpt}). It is therefore an essential information source for the browser specific fingerprinting technique.\\

The following properties are queried in the prototype:
\begin{itemize}
	\item \textit{screen: }allows to query information like the screen heigth and width or color depth.
	\item \textit{navigator: }enables the retrieval of information of different configurations and plugins (see below).\\
\end{itemize}

\begin{JsCode}
	if (window.screen) {
		var screenAvailWidth = window.screen.availWidth;
		var screenAvailHeight = window.screen.availHeight;
		var screenWidth = window.screen.width;
		var screenHeight = window.screen.height;
		var screenColorDepth = window.screen.colorDepth;
	}
\end{JsCode}
As documented in the code above, it is a simple property call to retrieve individual measurements from users.\\\\
Navigator is one of the properties of the window object and the main source of the information needed for creating the browser specific fingerprint in this thesis (\textcite{javatpt}). It is read-only and can be accessed via window.navigator or simply navigator(\textcite{nav19}).\\

Information queried with the help of window.navigator (\textcite{nav19}):
\begin{itemize}
	\item \textit{language: }returns the preferred language which is used in the browser UI (null if unknown).
	\item \textit{languages: }returns all languages which are known by the browser.
	\item \textit{user agent string: }returns the user agent string of the browser (see \autoref{UAS}).
	\item \textit{cookieEnabled: }returns a boolean if a cookie can be set or will be ignored.
	\item \textit{doNotTrack: }returns 'yes' or 'no' depending on the users doNotTrack setting.
	\item \textit{hardwareConcurrency: }returns the number of available logical processor cores.
	\item \textit{maxTouchPoints: }returns the value of maximal concurrent touch contact points of the used device.
	\item \textit{plugins: }returns an array which holds all installed plugins in the browser.\\
\end{itemize}
All of the queries properties return a boolean, integer or string except for plugins. Plugins returns a pluginarray which is not a JavaScript array but still possesses a length property (\textcite{nav19}).\\
\begin{JsCode}
	var pluginCount = navigator.plugins.length;
	var plugins = "";
	
	for (var i = 0; i < pluginCount; i++) {
		var version = navigator.plugins[i].version ? navigator.plugins[i].version
		: "x";
		plugins += navigator.plugins[i].name + ", "
		+ navigator.plugins[i].description + "(" + version
		+ "), " + navigator.plugins[i].filename + " | ";
	}
\end{JsCode}
As the code above shows how easily specific information about the plugins can be retrieves to be used for the creation of a browser specific fingerprint.\\\\
Additional to the information queried from the window properties, the prototype also includes the users gpu (graphic processing unit) (\autoref{sec:graphicCard}) and font check (\autoref{sec:fonts}) in the fingerprint.\\\\
After retrieving the necessary information mentioned above, the prototype concats the pieces of information and the created string serves as fingerprinting hash.

\subsubsection{Fingerprint}
As mentioned above the hash which is created by the prototype consists of a concatenation of all retrieved information about the user.\\\\
The example below was retrieved from a device running Windows 10 as an operating system. The fingerprint tells that a Vivaldi Browser was used, the window has the measurements 1280 x 720 and the used lanugage is German. The booleans concatinated with " - " are generated by the font method and depict which fonts are installed.
\begin{figure}[H]
	\centering
	\includegraphics[width=460pt, height=100pt]{browserSpecFingerprint.png}
	\caption{Example for a browser specific fingerprint\\}
	\label{fig:specFP}
\end{figure}

\subsection{Canvas fingerprinting} \label{sec:codeCanvas}

As outlined in \autoref{canvasfp} the canvas fingerprint consists of pixel data which is retrieved from a canvas in the users browser. This canvas is rendered through the use of JavaScript in the users browser and not allocated to HTML thus appearing hidden. Therefore the user does not see the rendered fonts, colors and forms.\\

\begin{JsCode}
		var canvas = null;
		var canvasInput = null;
		var hash = null;
		var allSigns = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~1!2@3#4$5%6^7&8*9(0)-_=+[{]}|;:',<.>/?";
		
		try {
			// create canvas
			canvas = document.createElement('canvas');
			
			// fill canvas
			canvasInput = canvas.getContext('2d');
			canvasInput.textBaseline = "top";
			canvasInput.font = "14px 'Arial'";
			canvasInput.textBaseline = "alphabetic";
			canvasInput.fillStyle = "#f60";
			canvasInput.fillRect(125, 1, 62, 20);
			canvasInput.fillText(allSigns, 2, 15);
		}
\end{JsCode}
The code above was written based on the two websites \textit{browserleaks} (\textcite{browserleaks}) and \textit{darkwavetech} (\textcite{jkula17}).\\\\
As seen a canvas is created and an input variable (canvasInput) is prepared. The '2d' written in the getContext method leads to the creation of a CanvasRenderingContext2D obext which represents a two-dimensional rendering context. This depicted in the code snipped above, this context is used to render not only fonts but also colors and rectangles. To render text various different letters and signs are used to recover pixeldata which is as diverse as possible.\\\\
After filling the canvas with input \textit{canvas.toDataURL()} is called which returns the Base64 encoded representation of pixel data. This string is then concatenated with the retrieved GPU which creates the used canvas fingerprint.\\\\

\subsubsection{Fingerprint}
As mentioned above the canvas fingerprint mainly consist of Base64 encoded pixel data. Ad Base64 encoded data is not readably for the human eye (see \autoref{fig:canvasFP}), the retrieved GPU (\autoref{sec:graphicCard}) is concatenated at the beginning of the pixel data. 
\begin{figure}[H]
	\centering
	\includegraphics[width=460pt, height=250pt]{canvasFingerprint.png}
	\caption{Example for a canvas fingerprint\\}
	\label{fig:canvasFP}
\end{figure}
The enormous amount of input in the canvas resulted in an extraordinarily long output string. The longer the fingerprint the more data is available for comparison and to discover differences. As the fingerprint is multiple pages long it has been croped for the depiction above.

\section{Visualisation}

Even tough the focus of the prototype lay on the creation and comparison of fingerprints, the prototype should be easy to use for the user. For the layout a few CSS files were used and each fingerprint is plainly explained (see \autoref{fig:PrototypeDesign}).\\\\
The usage is simple as only a button needs to be pressed and the user receives feedback immediately. The feedback depends on the creation and comparison (see \autoref{fig:PrototypeResult}).

\begin{figure}[H]
	\centering
	\includegraphics[width=320pt, height=270pt]{prototype.png}
	\caption{Prototype design, fingerprints can be created\\}
	\label{fig:PrototypeDesign}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=320pt, height=270pt]{prototypeResult.png}
	\caption{Prototype displays feedback for the user\\}
	\label{fig:PrototypeResult}
\end{figure}

